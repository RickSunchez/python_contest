## isEven

Небольшой анализ по способам определения четности числа показывает, что принципиальной разницы по скорости работы алгоритмов нет. Тут больше вопрос личных предпочтений и понятности кода. Основное преимущество стандартного деления с остатком - это его предельная понятность.

Выбирая из предложенного мной алгоритма и алгоритма из задания я бы выбрал второе.

## FIFO

Реализованы два буфера: 

- классический (с использованием индексов)
- с использованием list

Оба буфера рассчитаны на работу с целыми числами и имеют идентичную структуру.

### Классический буфер (FIFOIndexes)

Плюсы:

- универсальность алгоритма (в таком виде его можно реализовать на любом языке программирования)
- фиксированный размер памяти (место для буфера выделяется во время инициации класса)

Минусы:

- фиксированный размер памяти (при увеличении размера буфера, увеличивается и расход памяти)
- использование дополнительных переменных для хранения индексов

### Буфер на списке (FIFOList)

Плюсы:

- простота реализации
- скорость алгоритма, при работе с относительно небольшим размером буфера (как показывают тесты, методы `append()` и `pop()` хорошо себя показывают с массивами до миллиона записей)
- динамическая память (выделяется память под размер буфера)

Минусы:

- динамическая память (тут в основном вопросы к стабильности работы при нехватке памяти)
- сложности переносимости алгоритма на другие языки программирования (имеено в таком виде, в котором он есть)

## Сортировка

Тут, я позволю себе немного схитрить и воспользоваться своими наработками. В прошлом году я уже реализовывал алгоритм быстрой сортировки и даже [есть видео](https://youtu.be/JBJb_BaucHs).

Если говорить о ресурсах процессора, то работа алгоритма сильно зависит от выбора опорного элемента и изначальных данных. На практических данных алгоритм показывает хорошие результаты.

К основным плюсам работы алгоритма можно отнести его естественные возможности для распараллеливания процесса вычисления. Рекурсивные вызовы можно передавать в подпроцессы и в таком случае - скорость алгоритма увеличивается в разы.

Алгоритм можно доработать, введя дополнительную проверку на отсортированный массив и добавление критерия выбора опорного элемента.